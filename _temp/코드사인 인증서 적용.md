# 코드 사인 적용
윈도우 실행 파일에 `코드 서명(Code Signing)`을 해주는 절차

* 코드 서명 인증서
  - EV Code Signing (USB 토큰 필요, Microsoft SmartScreen 신뢰 쌓기 빠름)
  - OV Code Signing (일반 인증서, 보급형)
  - 인증 기관에서 발급 가능

* 서명 도구
  - Windows SDK에 포함된 `signtool.exe`

* 앱 실행 파일(app.exe) 또는 nsis 인스톨러에 서명을 적용
* 타임스탬프를 넣어야 인증서 만료 후에도 서명 유효 유지

## 앱 실행 파일(app.exe) 서명

`알 수 없는 게시자` 경고가 안 뜹니다.

```ps
signtool sign /f "C:\certs\mycert.pfx"              # /f : pfx 인증서 경로
              /p "비밀번호"                         # /p : 인증서 비밀번호
              /tr "http://timestamp.digicert.com"   # /tr : 타임스탬프 서버 (중요)
              /td sha256                            # /td : 타임스탬프 다이제스트 알고리즘
              /fd sha256                            # /fd : 파일 다이제스트 알고리즘
              "dist\myapp.exe"
```

## 인스톨러(NSIS) 서명

UAC 경고에서 `확인되지 않은 게시자` 경고가 안 뜹니다.  
인스톨러를 쓸 경우에는 설치파일도 다시 서명해야 합니다.

```ps
signtool sign /f "C:\certs\mycert.pfx" 
              /p "비밀번호" 
              /tr "http://timestamp.digicert.com" 
              /td sha256 
              /fd sha256 
              "dist\myapp-setup.exe"
```

## 서명 방법

### package.json 스크립트
```json
{
  "scripts": {
    "sign": "signtool sign /f ...",
    "release": "npm run build && npm run sign"
  }
}

```

### Node.js 스크립트

```js
// scripts/sign.js
const { execSync } = require("child_process");
const path = require("path");

const certPath = "C:\\certs\\mycert.pfx";
const password = "비밀번호";
const timestamp = "http://timestamp.digicert.com";

const files = [
  path.resolve("dist/win-unpacked/myapp.exe"),
  path.resolve("dist/myapp-setup.exe"),
];

files.forEach(file => {
    console.log(`Signing ${file}`);
    execSync(
        `signtool sign /f "${certPath}" /p ${password} /tr ${timestamp} /td sha256 /fd sha256 "${file}"`,
        { stdio: "inherit" }
    );
});
```

# 임시 테스트 방법

관리자 권한 PowerShell 실행

### 자체 서명(Self-Signed Certificate) 만들기

```ps
# 개발/테스트 용도 (공식 배포용은 불가)
New-SelfSignedCertificate -Type CodeSigningCert     # 인증서 용도 (exe, dll 같은 실행 파일에 서명)
                          -Subject "CN=MyTestCert"  # 인증서의 이름(주체, Subject DN) 지정, 나중에 인증서 목록에서 이 이름으로 찾을 수 있음
                          -CertStoreLocation Cert:\CurrentUser\My   # 인증서를 어디에 저장할지 지정
                          
# (Cert:\) PowerShell에서 제공하는 인증서 저장소 가상 드라이브
# (CurrentUser\My) 현재 로그인한 사용자 계정의 개인 인증서 저장소(개인용 인증서 폴더)
# 즉, 생성된 인증서는 Windows의 “개인 인증서 > 현재 사용자” 저장소에 보관
```
- 이렇게 하면 `내 인증서 저장소`에 테스트용 코드 서명 인증서가 생성됨
- (Windows에 `MyTestCert`라는 이름의 코드 서명용 자체 서명 인증서가 추가됨)
- 이후 이 인증서를 `pfx`로 내보내면 (추출해서) `signtool`에서 사용

### 생성된 인증서 확인

* Win + R > `certmgr.msc` 입력 : 인증서 관리자 창이 열립니다.
* 왼쪽 트리에서 `개인 > 인증서` 선택하면, 방금 만든 CN=MyTestCert 인증서를 확인

### 인증서를 pfx로 내보내기

```ps
$pwd = ConvertTo-SecureString -String "비밀번호" -Force -AsPlainText;
Export-PfxCertificate -Cert (Get-ChildItem -Path Cert:\CurrentUser\My | Where-Object { $_.Subject -match "MyTestCert" }) -FilePath C:\certs\mytest.pfx -Password $pwd
```

### signtool로 서명

```ps
signtool sign /f C:\certs\mytest.pfx /p 비밀번호 /fd sha256 /tr http://timestamp.digicert.com /td sha256 dist\myapp.exe
```

### 실행 결과 확인

- 서명된 exe 속성 > 디지털 서명 탭 > `MyTestCert` 인증서 확인.
- Windows 신뢰 기관에 등록되지 않은 인증서이므로 `SmartScreen/UAC`에서는 여전히 `알 수 없는 게시자`로 뜸.
- 신뢰 기관에 등록된 인증서 사용하면 `알 수 없는 게시자` 경고가 사라짐.

## SmartScreen/UAC 경고 제거 테스트

직접 루트 저장소에 등록
- 로컬 PC의 신뢰할 수 있는 루트 인증서 저장소(Trusted Root CA) 에 직접 추가

### UAC 대체 테스트
- 그 PC에서 실행 시 `UAC`에서 `알 수 없는 게시자` 대신 `게시자: 내 인증서 이름` 으로 표시됨.
- 단, 다른 PC에서는 다시 `알 수 없는 게시자` 경고 뜸.

### SmartScreen 테스트 불가
- 자가서명 인증서로는 SmartScreen 경고 제거 불가능.
- (공인 CA 인증서를 구입해야만 실제 배포 환경과 동일하게 확인 가능)

```ps
# 인증서를 로컬 신뢰 루트 저장소에 설치
certutil -addstore "Root" C:\certs\mytest.cer
```















